"""
This type stub file was generated by pyright.
"""

from collections.abc import Mapping
from typing import Literal, Protocol, TYPE_CHECKING, TypeAlias, TypeVar, TypedDict, final
from _typeshed import Incomplete

if TYPE_CHECKING:
    SupportsBufferProtocol: TypeAlias = Incomplete
    Array: TypeAlias = Incomplete
    Device: TypeAlias = Incomplete
    DType: TypeAlias = Incomplete
else:
    ...
_T_co = TypeVar("_T_co", covariant=True)
@final
class JustInt(Protocol):
    @property
    def __class__(self, /) -> type[int]:
        ...
    
    @__class__.setter
    def __class__(self, value: type[int], /) -> None:
        ...
    


@final
class JustFloat(Protocol):
    @property
    def __class__(self, /) -> type[float]:
        ...
    
    @__class__.setter
    def __class__(self, value: type[float], /) -> None:
        ...
    


@final
class JustComplex(Protocol):
    @property
    def __class__(self, /) -> type[complex]:
        ...
    
    @__class__.setter
    def __class__(self, value: type[complex], /) -> None:
        ...
    


class NestedSequence(Protocol[_T_co]):
    def __getitem__(self, key: int, /) -> _T_co | NestedSequence[_T_co]:
        ...
    
    def __len__(self, /) -> int:
        ...
    


class SupportsArrayNamespace(Protocol[_T_co]):
    def __array_namespace__(self, /, *, api_version: str | None) -> _T_co:
        ...
    


class HasShape(Protocol[_T_co]):
    @property
    def shape(self, /) -> _T_co:
        ...
    


Capabilities = TypedDict("Capabilities", { "boolean indexing": bool,"data-dependent shapes": bool,"max dimensions": int })
DefaultDTypes = TypedDict("DefaultDTypes", { "real floating": DType,"complex floating": DType,"integral": DType,"indexing": DType })
_DTypeKind: TypeAlias = Literal["bool", "signed integer", "unsigned integer", "integral", "real floating", "complex floating", "numeric",]
DTypeKind: TypeAlias = _DTypeKind | tuple[_DTypeKind, ...]
class DTypesBool(TypedDict):
    bool: DType
    ...


class DTypesSigned(TypedDict):
    int8: DType
    int16: DType
    int32: DType
    int64: DType
    ...


class DTypesUnsigned(TypedDict):
    uint8: DType
    uint16: DType
    uint32: DType
    uint64: DType
    ...


class DTypesIntegral(DTypesSigned, DTypesUnsigned):
    ...


class DTypesReal(TypedDict):
    float32: DType
    float64: DType
    ...


class DTypesComplex(TypedDict):
    complex64: DType
    complex128: DType
    ...


class DTypesNumeric(DTypesIntegral, DTypesReal, DTypesComplex):
    ...


class DTypesAll(DTypesBool, DTypesNumeric):
    ...


DTypesAny: TypeAlias = Mapping[str, DType]
__all__ = ["Array", "Capabilities", "DType", "DTypeKind", "DTypesAny", "DTypesAll", "DTypesBool", "DTypesNumeric", "DTypesIntegral", "DTypesSigned", "DTypesUnsigned", "DTypesReal", "DTypesComplex", "DefaultDTypes", "Device", "HasShape", "Namespace", "JustInt", "JustFloat", "JustComplex", "NestedSequence", "SupportsArrayNamespace", "SupportsBufferProtocol"]
def __dir__() -> list[str]:
    ...

