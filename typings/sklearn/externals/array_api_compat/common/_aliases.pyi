"""
This type stub file was generated by pyright.
"""

from typing import Any, NamedTuple, Optional, Sequence, TYPE_CHECKING
from ._typing import Array, DType, Device, Namespace

"""
These are functions that are just aliases of existing functions in NumPy.
"""
if TYPE_CHECKING:
    ...
def arange(start: float, /, stop: float | None = ..., step: float = ..., *, xp: Namespace, dtype: DType | None = ..., device: Device | None = ..., **kwargs: object) -> Array:
    ...

def empty(shape: int | tuple[int, ...], xp: Namespace, *, dtype: DType | None = ..., device: Device | None = ..., **kwargs: object) -> Array:
    ...

def empty_like(x: Array, /, xp: Namespace, *, dtype: DType | None = ..., device: Device | None = ..., **kwargs: object) -> Array:
    ...

def eye(n_rows: int, n_cols: int | None = ..., /, *, xp: Namespace, k: int = ..., dtype: DType | None = ..., device: Device | None = ..., **kwargs: object) -> Array:
    ...

def full(shape: int | tuple[int, ...], fill_value: complex, xp: Namespace, *, dtype: DType | None = ..., device: Device | None = ..., **kwargs: object) -> Array:
    ...

def full_like(x: Array, /, fill_value: complex, *, xp: Namespace, dtype: DType | None = ..., device: Device | None = ..., **kwargs: object) -> Array:
    ...

def linspace(start: float, stop: float, /, num: int, *, xp: Namespace, dtype: DType | None = ..., device: Device | None = ..., endpoint: bool = ..., **kwargs: object) -> Array:
    ...

def ones(shape: int | tuple[int, ...], xp: Namespace, *, dtype: DType | None = ..., device: Device | None = ..., **kwargs: object) -> Array:
    ...

def ones_like(x: Array, /, xp: Namespace, *, dtype: DType | None = ..., device: Device | None = ..., **kwargs: object) -> Array:
    ...

def zeros(shape: int | tuple[int, ...], xp: Namespace, *, dtype: DType | None = ..., device: Device | None = ..., **kwargs: object) -> Array:
    ...

def zeros_like(x: Array, /, xp: Namespace, *, dtype: DType | None = ..., device: Device | None = ..., **kwargs: object) -> Array:
    ...

class UniqueAllResult(NamedTuple):
    values: Array
    indices: Array
    inverse_indices: Array
    counts: Array
    ...


class UniqueCountsResult(NamedTuple):
    values: Array
    counts: Array
    ...


class UniqueInverseResult(NamedTuple):
    values: Array
    inverse_indices: Array
    ...


def unique_all(x: Array, /, xp: Namespace) -> UniqueAllResult:
    ...

def unique_counts(x: Array, /, xp: Namespace) -> UniqueCountsResult:
    ...

def unique_inverse(x: Array, /, xp: Namespace) -> UniqueInverseResult:
    ...

def unique_values(x: Array, /, xp: Namespace) -> Array:
    ...

def std(x: Array, /, xp: Namespace, *, axis: int | tuple[int, ...] | None = ..., correction: float = ..., keepdims: bool = ..., **kwargs: object) -> Array:
    ...

def var(x: Array, /, xp: Namespace, *, axis: int | tuple[int, ...] | None = ..., correction: float = ..., keepdims: bool = ..., **kwargs: object) -> Array:
    ...

def cumulative_sum(x: Array, /, xp: Namespace, *, axis: int | None = ..., dtype: DType | None = ..., include_initial: bool = ..., **kwargs: object) -> Array:
    ...

def cumulative_prod(x: Array, /, xp: Namespace, *, axis: int | None = ..., dtype: DType | None = ..., include_initial: bool = ..., **kwargs: object) -> Array:
    ...

def clip(x: Array, /, min: float | Array | None = ..., max: float | Array | None = ..., *, xp: Namespace, out: Array | None = ...) -> Array:
    ...

def permute_dims(x: Array, /, axes: tuple[int, ...], xp: Namespace) -> Array:
    ...

def reshape(x: Array, /, shape: tuple[int, ...], xp: Namespace, *, copy: Optional[bool] = ..., **kwargs: object) -> Array:
    ...

def argsort(x: Array, /, xp: Namespace, *, axis: int = ..., descending: bool = ..., stable: bool = ..., **kwargs: object) -> Array:
    ...

def sort(x: Array, /, xp: Namespace, *, axis: int = ..., descending: bool = ..., stable: bool = ..., **kwargs: object) -> Array:
    ...

def nonzero(x: Array, /, xp: Namespace, **kwargs: object) -> tuple[Array, ...]:
    ...

def ceil(x: Array, /, xp: Namespace, **kwargs: object) -> Array:
    ...

def floor(x: Array, /, xp: Namespace, **kwargs: object) -> Array:
    ...

def trunc(x: Array, /, xp: Namespace, **kwargs: object) -> Array:
    ...

def matmul(x1: Array, x2: Array, /, xp: Namespace, **kwargs: object) -> Array:
    ...

def matrix_transpose(x: Array, /, xp: Namespace) -> Array:
    ...

def tensordot(x1: Array, x2: Array, /, xp: Namespace, *, axes: int | tuple[Sequence[int], Sequence[int]] = ..., **kwargs: object) -> Array:
    ...

def vecdot(x1: Array, x2: Array, /, xp: Namespace, *, axis: int = ...) -> Array:
    ...

def isdtype(dtype: DType, kind: DType | str | tuple[DType | str, ...], xp: Namespace, *, _tuple: bool = ...) -> bool:
    """
    Returns a boolean indicating whether a provided dtype is of a specified data type ``kind``.

    Note that outside of this function, this compat library does not yet fully
    support complex numbers.

    See
    https://data-apis.org/array-api/latest/API_specification/generated/array_api.isdtype.html
    for more details
    """
    ...

def unstack(x: Array, /, xp: Namespace, *, axis: int = ...) -> tuple[Array, ...]:
    ...

def sign(x: Array, /, xp: Namespace, **kwargs: object) -> Array:
    ...

def finfo(type_: DType | Array, /, xp: Namespace) -> Any:
    ...

def iinfo(type_: DType | Array, /, xp: Namespace) -> Any:
    ...

__all__ = ["arange", "empty", "empty_like", "eye", "full", "full_like", "linspace", "ones", "ones_like", "zeros", "zeros_like", "UniqueAllResult", "UniqueCountsResult", "UniqueInverseResult", "unique_all", "unique_counts", "unique_inverse", "unique_values", "std", "var", "cumulative_sum", "cumulative_prod", "clip", "permute_dims", "reshape", "argsort", "sort", "nonzero", "ceil", "floor", "trunc", "matmul", "matrix_transpose", "tensordot", "vecdot", "isdtype", "unstack", "sign", "finfo", "iinfo"]
_all_ignore = ...
def __dir__() -> list[str]:
    ...

