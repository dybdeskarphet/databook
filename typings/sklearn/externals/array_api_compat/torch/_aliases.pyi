"""
This type stub file was generated by pyright.
"""

from typing import Any, List, Literal, Optional, Sequence, Tuple, Union
from ..common._typing import NestedSequence, SupportsBufferProtocol
from ._typing import Array, DType, Device
from ..common._aliases import UniqueAllResult, UniqueCountsResult, UniqueInverseResult

_int_dtypes = ...
_array_api_dtypes = ...
_promotion_table = ...
_py_scalars = ...
def result_type(*arrays_and_dtypes: Array | DType | bool | int | float | complex) -> DType:
    ...

def can_cast(from_: Union[DType, Array], to: DType, /) -> bool:
    ...

bitwise_invert = ...
newaxis = ...
conj = ...
add = ...
atan2 = ...
bitwise_and = ...
bitwise_left_shift = ...
bitwise_or = ...
bitwise_right_shift = ...
bitwise_xor = ...
copysign = ...
divide = ...
equal = ...
floor_divide = ...
greater = ...
greater_equal = ...
hypot = ...
less = ...
less_equal = ...
logaddexp = ...
maximum = ...
minimum = ...
multiply = ...
not_equal = ...
pow = ...
remainder = ...
subtract = ...
def asarray(obj: (Array | bool | int | float | complex | NestedSequence[bool | int | float | complex] | SupportsBufferProtocol), /, *, dtype: DType | None = ..., device: Device | None = ..., copy: bool | None = ..., **kwargs: Any) -> Array:
    ...

def max(x: Array, /, *, axis: Optional[Union[int, Tuple[int, ...]]] = ..., keepdims: bool = ...) -> Array:
    ...

def min(x: Array, /, *, axis: Optional[Union[int, Tuple[int, ...]]] = ..., keepdims: bool = ...) -> Array:
    ...

clip = ...
unstack = ...
cumulative_sum = ...
cumulative_prod = ...
finfo = ...
iinfo = ...
def sort(x: Array, /, *, axis: int = ..., descending: bool = ..., stable: bool = ..., **kwargs) -> Array:
    ...

def prod(x: Array, /, *, axis: Optional[Union[int, Tuple[int, ...]]] = ..., dtype: Optional[DType] = ..., keepdims: bool = ..., **kwargs) -> Array:
    ...

def sum(x: Array, /, *, axis: Optional[Union[int, Tuple[int, ...]]] = ..., dtype: Optional[DType] = ..., keepdims: bool = ..., **kwargs) -> Array:
    ...

def any(x: Array, /, *, axis: Optional[Union[int, Tuple[int, ...]]] = ..., keepdims: bool = ..., **kwargs) -> Array:
    ...

def all(x: Array, /, *, axis: Optional[Union[int, Tuple[int, ...]]] = ..., keepdims: bool = ..., **kwargs) -> Array:
    ...

def mean(x: Array, /, *, axis: Optional[Union[int, Tuple[int, ...]]] = ..., keepdims: bool = ..., **kwargs) -> Array:
    ...

def std(x: Array, /, *, axis: Optional[Union[int, Tuple[int, ...]]] = ..., correction: Union[int, float] = ..., keepdims: bool = ..., **kwargs) -> Array:
    ...

def var(x: Array, /, *, axis: Optional[Union[int, Tuple[int, ...]]] = ..., correction: Union[int, float] = ..., keepdims: bool = ..., **kwargs) -> Array:
    ...

def concat(arrays: Union[Tuple[Array, ...], List[Array]], /, *, axis: Optional[int] = ..., **kwargs) -> Array:
    ...

def squeeze(x: Array, /, axis: Union[int, Tuple[int, ...]]) -> Array:
    ...

def broadcast_to(x: Array, /, shape: Tuple[int, ...], **kwargs) -> Array:
    ...

def permute_dims(x: Array, /, axes: Tuple[int, ...]) -> Array:
    ...

def flip(x: Array, /, *, axis: Optional[Union[int, Tuple[int, ...]]] = ..., **kwargs) -> Array:
    ...

def roll(x: Array, /, shift: Union[int, Tuple[int, ...]], *, axis: Optional[Union[int, Tuple[int, ...]]] = ..., **kwargs) -> Array:
    ...

def nonzero(x: Array, /, **kwargs) -> Tuple[Array, ...]:
    ...

def diff(x: Array, /, *, axis: int = ..., n: int = ..., prepend: Optional[Array] = ..., append: Optional[Array] = ...) -> Array:
    ...

def count_nonzero(x: Array, /, *, axis: Optional[Union[int, Tuple[int, ...]]] = ..., keepdims: bool = ...) -> Array:
    ...

def repeat(x: Array, repeats: int | Array, /, *, axis: int | None = ...) -> Array:
    ...

def where(condition: Array, x1: Array | bool | int | float | complex, x2: Array | bool | int | float | complex, /) -> Array:
    ...

def reshape(x: Array, /, shape: Tuple[int, ...], *, copy: Optional[bool] = ..., **kwargs) -> Array:
    ...

def arange(start: Union[int, float], /, stop: Optional[Union[int, float]] = ..., step: Union[int, float] = ..., *, dtype: Optional[DType] = ..., device: Optional[Device] = ..., **kwargs) -> Array:
    ...

def eye(n_rows: int, n_cols: Optional[int] = ..., /, *, k: int = ..., dtype: Optional[DType] = ..., device: Optional[Device] = ..., **kwargs) -> Array:
    ...

def linspace(start: Union[int, float], stop: Union[int, float], /, num: int, *, dtype: Optional[DType] = ..., device: Optional[Device] = ..., endpoint: bool = ..., **kwargs) -> Array:
    ...

def full(shape: Union[int, Tuple[int, ...]], fill_value: bool | int | float | complex, *, dtype: Optional[DType] = ..., device: Optional[Device] = ..., **kwargs) -> Array:
    ...

def ones(shape: Union[int, Tuple[int, ...]], *, dtype: Optional[DType] = ..., device: Optional[Device] = ..., **kwargs) -> Array:
    ...

def zeros(shape: Union[int, Tuple[int, ...]], *, dtype: Optional[DType] = ..., device: Optional[Device] = ..., **kwargs) -> Array:
    ...

def empty(shape: Union[int, Tuple[int, ...]], *, dtype: Optional[DType] = ..., device: Optional[Device] = ..., **kwargs) -> Array:
    ...

def tril(x: Array, /, *, k: int = ...) -> Array:
    ...

def triu(x: Array, /, *, k: int = ...) -> Array:
    ...

def expand_dims(x: Array, /, *, axis: int = ...) -> Array:
    ...

def astype(x: Array, dtype: DType, /, *, copy: bool = ..., device: Optional[Device] = ...) -> Array:
    ...

def broadcast_arrays(*arrays: Array) -> List[Array]:
    ...

def unique_all(x: Array) -> UniqueAllResult:
    ...

def unique_counts(x: Array) -> UniqueCountsResult:
    ...

def unique_inverse(x: Array) -> UniqueInverseResult:
    ...

def unique_values(x: Array) -> Array:
    ...

def matmul(x1: Array, x2: Array, /, **kwargs) -> Array:
    ...

matrix_transpose = ...
_vecdot = ...
def vecdot(x1: Array, x2: Array, /, *, axis: int = ...) -> Array:
    ...

def tensordot(x1: Array, x2: Array, /, *, axes: Union[int, Tuple[Sequence[int], Sequence[int]]] = ..., **kwargs) -> Array:
    ...

def isdtype(dtype: DType, kind: Union[DType, str, Tuple[Union[DType, str], ...]], *, _tuple=...) -> bool:
    """
    Returns a boolean indicating whether a provided dtype is of a specified data type ``kind``.

    Note that outside of this function, this compat library does not yet fully
    support complex numbers.

    See
    https://data-apis.org/array-api/latest/API_specification/generated/array_api.isdtype.html
    for more details
    """
    ...

def take(x: Array, indices: Array, /, *, axis: Optional[int] = ..., **kwargs) -> Array:
    ...

def take_along_axis(x: Array, indices: Array, /, *, axis: int = ...) -> Array:
    ...

def sign(x: Array, /) -> Array:
    ...

def meshgrid(*arrays: Array, indexing: Literal['xy', 'ij'] = ...) -> List[Array]:
    ...

__all__ = ['__array_namespace_info__', 'asarray', 'result_type', 'can_cast', 'permute_dims', 'bitwise_invert', 'newaxis', 'conj', 'add', 'atan2', 'bitwise_and', 'bitwise_left_shift', 'bitwise_or', 'bitwise_right_shift', 'bitwise_xor', 'copysign', 'count_nonzero', 'diff', 'divide', 'equal', 'floor_divide', 'greater', 'greater_equal', 'hypot', 'less', 'less_equal', 'logaddexp', 'maximum', 'minimum', 'multiply', 'not_equal', 'pow', 'remainder', 'subtract', 'max', 'min', 'clip', 'unstack', 'cumulative_sum', 'cumulative_prod', 'sort', 'prod', 'sum', 'any', 'all', 'mean', 'std', 'var', 'concat', 'squeeze', 'broadcast_to', 'flip', 'roll', 'nonzero', 'where', 'reshape', 'arange', 'eye', 'linspace', 'full', 'ones', 'zeros', 'empty', 'tril', 'triu', 'expand_dims', 'astype', 'broadcast_arrays', 'UniqueAllResult', 'UniqueCountsResult', 'UniqueInverseResult', 'unique_all', 'unique_counts', 'unique_inverse', 'unique_values', 'matmul', 'matrix_transpose', 'vecdot', 'tensordot', 'isdtype', 'take', 'take_along_axis', 'sign', 'finfo', 'iinfo', 'repeat', 'meshgrid']
_all_ignore = ...
